"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateMigrationStub = void 0;
const fs_1 = require("fs");
const validation_1 = require("../../../utils/validation");
const migration_1 = require("../../../utils/migration");
const php_base_1 = require("../php-base");
class GenerateMigrationStub extends php_base_1.BasePhpStubStep {
    constructor() {
        super(...arguments);
        this.type = 'Generate Migration';
        this.schema = {
            root: './',
            recommendedSubdir: 'migrations',
            forceRecommendedSubdir: true,
            sourceFile: 'migration.php',
            params: [
                {
                    name: 'name',
                    type: 'text',
                    message: 'Migration name/short description',
                    validate: validation_1.Validator.migrationName,
                },
            ],
        };
    }
    async compileParams(fs, paths, io) {
        var _a;
        const params = await super.compileParams(fs, paths, io);
        const regex = new RegExp(/^create_([\dA-z]+)_table$/);
        if (regex.test(params.name)) {
            params.tableName = (_a = regex.exec(params.name)) === null || _a === void 0 ? void 0 : _a.pop();
        }
        return params;
    }
    async getFileName(fs, paths, _paramProvider) {
        let persistedMigrations;
        try {
            persistedMigrations = (0, fs_1.readdirSync)(paths.package('migrations'));
        }
        catch (_a) {
            persistedMigrations = [];
        }
        const memMigrations = fs
            .all()
            .map((f) => f.path)
            .filter((p) => p.startsWith(paths.package('migrations')));
        return (0, migration_1.getNextMigrationName)([...persistedMigrations, ...memMigrations], this.params.name) + '.php';
    }
}
exports.GenerateMigrationStub = GenerateMigrationStub;
