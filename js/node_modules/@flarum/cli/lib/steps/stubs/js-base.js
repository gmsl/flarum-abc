"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseJsStubStep = void 0;
const clone_and_fill_1 = require("../../boilersmith/utils/clone-and-fill");
const flarum_base_1 = require("./flarum-base");
class BaseJsStubStep extends flarum_base_1.FlarumBaseStubStep {
    constructor() {
        super(...arguments);
        this.defaultRoot = './js/src';
    }
    get exposes() {
        return [...super.exposes, 'className'];
    }
    get implicitParams() {
        return [...super.implicitParams, 'classNamespace'];
    }
    async precompileParams(fs, paths, io) {
        const params = await super.precompileParams(fs, paths, io);
        const paramDefs = this.schema.params.filter((param) => !this.implicitParams.includes(param.name));
        this.subdir =
            this.schema.forceRecommendedSubdir || paths.requestedDir() === null
                ? this.schema.recommendedSubdir
                : paths.requestedDir().slice(`${paths.package('js/src')}/`.length);
        params.frontend = await io.getParam(paramDefs.find((param) => param.name === 'frontend'));
        params.className = await io.getParam(paramDefs.find((param) => param.name === 'className'));
        this.subdir = (0, clone_and_fill_1.cloneAndFill)(this.subdir, params);
        params.classNamespace = `${this.subdir}/${params.className}`;
        return params;
    }
    async getFileName(_fs, _paths, io) {
        return (await io.getParam({ name: 'className', message: 'File name', type: 'text' })) + '.js';
    }
}
exports.BaseJsStubStep = BaseJsStubStep;
