"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genExtScaffolder = exports.EXTENSION_MODULES = exports.EXTENSION_PARAMS = void 0;
const tslib_1 = require("tslib");
const scaffolder_1 = require("boilersmith/scaffolding/scaffolder");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const mem_fs_editor_1 = require("mem-fs-editor");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const simple_git_1 = (0, tslib_1.__importDefault)(require("simple-git"));
const simple_1 = (0, tslib_1.__importDefault)(require("spdx-license-list/simple"));
const composer_1 = require("../utils/composer");
function assertUnreachable(_x) {
    throw new Error("Didn't expect to get here");
}
exports.EXTENSION_PARAMS = [
    'packageName',
    'packageDescription',
    'packageNamespace',
    'authorName',
    'authorEmail',
    'extensionName',
    'licenseType',
    'mainGitBranch',
    'jsPackageManager',
    'licenseText',
    'extensionId',
    'year',
    'backendDirectory',
    'frontendDirectory',
];
function paramNamesToDef(name) {
    switch (name) {
        case 'packageName':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: `Package ${chalk_1.default.dim('(vendor/extension-name)')}`,
                    validate: (s) => /^([\dA-Za-z-]{2,})\/([\dA-Za-z-]{2,})$/.test(s.trim()) || 'Invalid package name format',
                    format: (s) => s.toLowerCase(),
                },
                getCurrVal: async (fs, paths) => {
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    return json === null || json === void 0 ? void 0 : json.name;
                },
            };
        case 'packageDescription':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: 'Package description',
                },
                getCurrVal: async (fs, paths) => {
                    var _a;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    return (_a = json === null || json === void 0 ? void 0 : json.description) !== null && _a !== void 0 ? _a : '';
                },
            };
        case 'packageNamespace':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: `Package namespace ${chalk_1.default.dim('(Vendor\\ExtensionName)')}`,
                    validate: (s) => /^([\dA-Za-z]+)\\([\dA-Za-z]+)$/.test(s.trim()) || 'Invalid namespace format',
                    format: (str) => str &&
                        str
                            .split('\\')
                            .map((s) => s[0].toUpperCase() + s.slice(1))
                            .join('\\'),
                },
                getCurrVal: async (fs, paths) => {
                    var _a, _b, _c, _d, _e;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    const namespace = (_e = ((_d = (_c = Object.keys((_b = (_a = json === null || json === void 0 ? void 0 : json.autoload) === null || _a === void 0 ? void 0 : _a['psr-4']) !== null && _b !== void 0 ? _b : {})) === null || _c === void 0 ? void 0 : _c[0]) !== null && _d !== void 0 ? _d : '')) === null || _e === void 0 ? void 0 : _e.slice(0, -1);
                    return namespace || '';
                },
            };
        case 'authorName':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: 'Author name',
                },
                getCurrVal: async (fs, paths) => {
                    var _a, _b, _c;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    return (_c = (_b = (_a = json.authors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : '';
                },
            };
        case 'authorEmail':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: 'Author email',
                    validate: (s) => !s || /^[\w!#$%&*+./=?^`{|}~â€™-]+@[\dA-Za-z-]+(?:\.[\dA-Za-z-]+)*$/.test(s) || 'Invalid email format',
                },
                getCurrVal: async (fs, paths) => {
                    var _a, _b, _c;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    return (_c = (_b = (_a = json.authors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.email) !== null && _c !== void 0 ? _c : '';
                },
            };
        case 'extensionName':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: 'Extension name',
                    validate: (str) => Boolean(str.trim()) || 'The extension name is required',
                    format: (str) => str
                        .split(' ')
                        .map((s) => (s.length > 3 ? s[0].toUpperCase() + s.slice(1) : s))
                        .join(' '),
                },
                getCurrVal: async (fs, paths) => {
                    var _a, _b, _c;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    if (json.name === 'flarum/core')
                        return 'Core';
                    return (_c = (_b = (_a = json === null || json === void 0 ? void 0 : json.extra) === null || _a === void 0 ? void 0 : _a['flarum-extension']) === null || _b === void 0 ? void 0 : _b.title) !== null && _c !== void 0 ? _c : '';
                },
            };
        case 'licenseType':
            return {
                prompt: {
                    name,
                    type: 'autocomplete',
                    message: 'License',
                    choices: [...simple_1.default].map((e) => ({ title: e, value: e })),
                },
                getCurrVal: async (fs, paths) => {
                    var _a;
                    const json = (0, composer_1.getComposerJson)(fs, paths);
                    return (_a = json === null || json === void 0 ? void 0 : json.license) !== null && _a !== void 0 ? _a : '';
                },
            };
        case 'licenseText':
            return {
                name,
                uses: ['licenseType'],
                compute: async (_paths, licenseType) => (licenseType ? require(`spdx-license-list/licenses/${licenseType}`).licenseText : ''),
            };
        case 'extensionId':
            return {
                name,
                uses: ['packageName'],
                compute: async (_paths, packageName) => packageName.replace(/(flarum-ext-)|(flarum-)/, '').replace('/', '-'),
            };
        case 'year':
            return {
                name,
                uses: [],
                compute: async () => new Date().getFullYear().toString(),
            };
        case 'mainGitBranch':
            return {
                prompt: {
                    name,
                    type: 'text',
                    message: `Main git branch ${chalk_1.default.dim('(JS will automatically build when changes are pushed to GitHub on this branch)')}`,
                    // See https://stackoverflow.com/a/12093994/11091039
                    validate: (s) => /^(?!.*\/\.)(?!.*\.\.)(?!\/)(?!.*\/\/)(?!.*@{)(?!.*\\)[^\000-\037 *:?[^~\177]+(?<!\.lock)(?<!\/)(?<!\.)$/.test(s.trim()) ||
                        'Invalid git branch',
                    initial: 'main',
                },
                getCurrVal: async (_fs, paths) => {
                    var _a, _b;
                    const cwd = (_a = paths.monorepo()) !== null && _a !== void 0 ? _a : paths.package();
                    try {
                        const remotes = (0, child_process_1.execSync)('git remote', { cwd, timeout: 2000 }).toString().split('\n');
                        if (remotes.includes('origin')) {
                            return (0, child_process_1.execSync)("git remote show origin | grep 'HEAD branch' | cut -d' ' -f5", { cwd, timeout: 2000 }).toString();
                        }
                    }
                    catch (_c) { }
                    return (_b = (await (0, simple_git_1.default)(cwd, { timeout: { block: 2000 } }).getConfig('init.defaultBranch')).value) !== null && _b !== void 0 ? _b : 'main';
                },
            };
        case 'jsPackageManager':
            return {
                prompt: {
                    name,
                    type: 'select',
                    message: 'JS Package Manager',
                    initial: 0,
                    choices: [
                        { title: 'Yarn', value: 'yarn' },
                        { title: 'NPM', value: 'npm' },
                    ],
                },
                getCurrVal: async (fs, paths) => {
                    return (0, mem_fs_editor_1.create)(fs).exists(paths.package('js/yarn.lock')) ? 'yarn' : 'npm';
                },
            };
        case 'backendDirectory':
            return {
                name,
                uses: [],
                compute: async (paths) => {
                    const monorepoPath = paths.monorepo();
                    return monorepoPath ? paths.package().replace(monorepoPath, '.') : '.';
                },
            };
        case 'frontendDirectory':
            return {
                name,
                uses: [],
                compute: async (paths) => {
                    const monorepoPath = paths.monorepo();
                    return monorepoPath ? paths.package().replace(monorepoPath, '.') + '/js' : './js';
                },
            };
    }
    return assertUnreachable(name);
}
exports.EXTENSION_MODULES = [
    'core',
    'icon',
    'admin',
    'forum',
    'js',
    'jsCommon',
    'css',
    'locale',
    'gitConf',
    'githubActions',
    'prettier',
    'typescript',
    'bundlewatch',
    'backendTesting',
    'editorConfig',
    'styleci',
];
function moduleNameToDef(name) {
    switch (name) {
        case 'core':
            return {
                name,
                updatable: false,
                togglable: false,
                shortDescription: 'Core Functionality',
                filesToReplace: ['extend.php', 'README.md', 'LICENSE.md'],
                jsonToAugment: {
                    'composer.json': [
                        'name',
                        'description',
                        'keywords',
                        'type',
                        'license',
                        'require.flarum/core',
                        'authors',
                        'autoload.psr-4.${params.packageNamespace}\\',
                        'extra.flarum-extension.title',
                        'extra.flarum-extension.category',
                        'minimum-stability',
                        'prefer-stable',
                    ],
                },
                needsTemplateParams: [
                    'packageName',
                    'packageNamespace',
                    'packageNamespace',
                    'packageDescription',
                    'extensionName',
                    'licenseType',
                    'licenseText',
                    'authorName',
                    'authorEmail',
                    'extensionId',
                    'year',
                ],
            };
        case 'icon':
            return {
                name,
                updatable: false,
                togglable: false,
                shortDescription: 'Extension Icon',
                filesToReplace: [],
                jsonToAugment: {
                    'composer.json': ['extra.flarum-extension.icon.name', 'extra.flarum-extension.icon.color', 'extra.flarum-extension.icon.backgroundColor'],
                },
                needsTemplateParams: [],
            };
        case 'admin':
            return {
                name,
                updatable: true,
                defaultEnabled: true,
                dependsOn: [],
                togglable: true,
                shortDescription: 'Admin Frontend',
                filesToReplace: [
                    { path: 'js/admin.js', moduleDeps: ['js', { module: 'typescript', enabled: false }] },
                    { path: 'js/admin.ts', moduleDeps: ['js', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/admin/index.js', doNotUpdate: true, moduleDeps: ['js', { module: 'typescript', enabled: false }] },
                    { path: 'js/src/admin/index.ts', doNotUpdate: true, moduleDeps: ['js', { module: 'typescript', enabled: true }] },
                ],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    if (!(0, fs_1.existsSync)(paths.package('js')))
                        undefined;
                    return (0, fs_1.existsSync)(paths.package('js/src/admin'));
                },
            };
        case 'forum':
            return {
                name,
                updatable: true,
                defaultEnabled: true,
                dependsOn: [],
                togglable: true,
                shortDescription: 'Forum Frontend',
                filesToReplace: [
                    { path: 'js/forum.js', moduleDeps: ['js', { module: 'typescript', enabled: false }] },
                    { path: 'js/forum.ts', moduleDeps: ['js', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/forum/index.js', doNotUpdate: true, moduleDeps: ['js', { module: 'typescript', enabled: false }] },
                    { path: 'js/src/forum/index.ts', doNotUpdate: true, moduleDeps: ['js', { module: 'typescript', enabled: true }] },
                ],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    if (!(0, fs_1.existsSync)(paths.package('js')))
                        undefined;
                    return (0, fs_1.existsSync)(paths.package('js/src/forum'));
                },
            };
        case 'js':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Javascript',
                longDescription: "Files, tools, and scripts to build Flarum's frontend.",
                dependsOn: [],
                filesToReplace: [
                    'js/webpack.config.js',
                    { path: 'js/admin.js', moduleDeps: ['admin', { module: 'typescript', enabled: false }] },
                    { path: 'js/forum.js', moduleDeps: ['forum', { module: 'typescript', enabled: false }] },
                    { path: 'js/admin.ts', moduleDeps: ['admin', { module: 'typescript', enabled: true }] },
                    { path: 'js/forum.ts', moduleDeps: ['forum', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/admin/index.js', doNotUpdate: true, moduleDeps: ['admin', { module: 'typescript', enabled: false }] },
                    { path: 'js/src/forum/index.js', doNotUpdate: true, moduleDeps: ['forum', { module: 'typescript', enabled: false }] },
                    { path: 'js/src/common/index.js', doNotUpdate: true, moduleDeps: ['jsCommon', { module: 'typescript', enabled: false }] },
                    { path: 'js/src/admin/index.ts', doNotUpdate: true, moduleDeps: ['admin', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/forum/index.ts', doNotUpdate: true, moduleDeps: ['forum', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/common/index.ts', doNotUpdate: true, moduleDeps: ['jsCommon', { module: 'typescript', enabled: true }] },
                ],
                jsonToAugment: {
                    'js/package.json': [
                        'name',
                        'private',
                        'version',
                        'devDependencies.flarum-webpack-config',
                        'devDependencies.webpack',
                        'devDependencies.webpack-cli',
                        'scripts.dev',
                        'scripts.build',
                        'scripts.analyze',
                    ],
                },
                needsTemplateParams: ['packageName', 'jsPackageManager'],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('js'));
                },
            };
        case 'jsCommon':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'JS common code',
                longDescription: 'Shared code between the forum and the admin frontends',
                dependsOn: ['js'],
                filesToReplace: [
                    { path: 'js/admin.js', moduleDeps: ['admin', { module: 'typescript', enabled: false }] },
                    { path: 'js/forum.js', moduleDeps: ['forum', { module: 'typescript', enabled: false }] },
                    { path: 'js/admin.ts', moduleDeps: ['admin', { module: 'typescript', enabled: true }] },
                    { path: 'js/forum.ts', moduleDeps: ['forum', { module: 'typescript', enabled: true }] },
                    { path: 'js/src/common/index.js', doNotUpdate: true, moduleDeps: [{ module: 'typescript', enabled: false }] },
                    { path: 'js/src/common/index.ts', doNotUpdate: true, moduleDeps: [{ module: 'typescript', enabled: true }] },
                ],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('js/src/common'));
                },
            };
        case 'css':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'CSS',
                longDescription: "LESS starter files for Flarum's frontend styling.",
                dependsOn: [],
                filesToReplace: [
                    { path: 'less/admin.less', doNotUpdate: true, moduleDeps: ['admin'] },
                    { path: 'less/forum.less', doNotUpdate: true, moduleDeps: ['forum'] },
                ],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('less'));
                },
            };
        case 'locale':
            return {
                name,
                updatable: false,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Locale',
                longDescription: 'Translation starter files.',
                dependsOn: [],
                filesToReplace: [{ path: 'locale/en.yml', doNotUpdate: true }],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('locale'));
                },
            };
        case 'gitConf':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Git Configuration',
                longDescription: 'Git config files (e.g. .gitignore, .gitattributes).',
                dependsOn: [],
                filesToReplace: [
                    { path: 'gitignore', destPath: '.gitignore' },
                    { path: 'js/gitignore', moduleDeps: ['js'], destPath: 'js/.gitignore' },
                    { path: '.gitattributes', monorepoPath: '.gitattributes' },
                ],
                jsonToAugment: {},
                needsTemplateParams: [],
            };
        case 'githubActions':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'GitHub Actions CI',
                longDescription: 'Automatically run checks via GitHub Actions CI. Free for open source projects.',
                dependsOn: [],
                filesToReplace: [
                    {
                        path: '.github/workflows/frontend.yml',
                        monorepoPath: '.github/workflows/${params.extensionId}-frontend.yml',
                        requireMonorepo: false,
                        moduleDeps: ['js'],
                    },
                    {
                        path: '.github/workflows/backend.yml',
                        monorepoPath: '.github/workflows/${params.extensionId}-backend.yml',
                        requireMonorepo: false,
                    },
                ],
                jsonToAugment: {},
                needsTemplateParams: ['frontendDirectory', 'backendDirectory', 'mainGitBranch', 'extensionId', 'extensionName'],
            };
        case 'prettier':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Auto-format frontend code with Prettier.',
                dependsOn: ['js'],
                filesToReplace: [],
                jsonToAugment: {
                    'js/package.json': [
                        'prettier',
                        'devDependencies.prettier',
                        'devDependencies.@flarum/prettier-config',
                        'scripts.format',
                        'scripts.format-check',
                    ],
                },
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    if (!(0, fs_1.existsSync)(paths.package('js/package.json'))) {
                        return false;
                    }
                    return (0, fs_1.readFileSync)(paths.package('js/package.json')).includes('prettier');
                },
            };
        case 'typescript':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Support TypeScript in frontend code.',
                dependsOn: ['js'],
                filesToReplace: ['js/tsconfig.json'],
                jsonToAugment: {
                    'js/package.json': [
                        'devDependencies.flarum-tsconfig',
                        'devDependencies.typescript',
                        'devDependencies.typescript-coverage-report',
                        'scripts.clean-typings',
                        'scripts.build-typings',
                        'scripts.post-build-typings',
                        'scripts.check-typings',
                        'scripts.check-typings-coverage',
                    ],
                },
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('js/tsconfig.json'));
                },
            };
        case 'bundlewatch':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: false,
                shortDescription: 'Enable Bundlewatch Checks',
                dependsOn: ['js'],
                filesToReplace: ['js/.bundlewatch.config.json'],
                jsonToAugment: {},
                needsTemplateParams: [],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('js/.bundlewatch.config.json'));
                },
            };
        case 'backendTesting':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'Backend PHP unit and integration testing via PHPUnit.',
                dependsOn: [],
                filesToReplace: [
                    'tests/phpunit.integration.xml',
                    'tests/phpunit.unit.xml',
                    'tests/fixtures/.gitkeep',
                    'tests/integration/setup.php',
                    'tests/unit/.gitkeep',
                ],
                jsonToAugment: {
                    'composer.json': [
                        'autoload-dev.psr-4.${params.packageNamespace}\\Tests\\',
                        'scripts.test',
                        'scripts.test:unit',
                        'scripts.test:integration',
                        'scripts.test:setup',
                        'scripts-descriptions.test',
                        'scripts-descriptions.test:unit',
                        'scripts-descriptions.test:integration',
                        'scripts-descriptions.test:setup',
                        'require-dev.flarum/testing',
                    ],
                },
                needsTemplateParams: ['packageNamespace'],
                inferEnabled: async (_fs, paths) => {
                    return (0, fs_1.existsSync)(paths.package('tests'));
                },
            };
        case 'editorConfig':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'EditorConfig setup',
                dependsOn: [],
                filesToReplace: ['.editorconfig'],
                jsonToAugment: {},
                needsTemplateParams: [],
            };
        case 'styleci':
            return {
                name,
                updatable: true,
                togglable: true,
                defaultEnabled: true,
                shortDescription: 'StyleCI config file',
                dependsOn: [],
                filesToReplace: [{ path: '.styleci.yml', monorepoPath: '.styleci.yml', requireMonorepo: false }],
                jsonToAugment: {},
                needsTemplateParams: [],
            };
    }
    return assertUnreachable(name);
}
let cached;
function genExtScaffolder() {
    if (cached)
        return cached;
    const moduleStatusCache = {
        get: async (module, fs, paths) => {
            var _a, _b, _c;
            const json = (0, composer_1.getComposerJson)(fs, paths);
            return !module.togglable || ((_c = (_b = (_a = json === null || json === void 0 ? void 0 : json.extra) === null || _a === void 0 ? void 0 : _a['flarum-cli']) === null || _b === void 0 ? void 0 : _b.modules) === null || _c === void 0 ? void 0 : _c[module.name]);
        },
        set: async (module, enabled, fs, paths) => {
            const json = {
                extra: {
                    'flarum-cli': {
                        modules: {
                            [module.name]: enabled,
                        },
                    },
                },
            };
            (0, mem_fs_editor_1.create)(fs).extendJSON(paths.package('composer.json'), json, undefined, 4);
        },
    };
    const excludeScaffoldingFunc = (fs, paths) => {
        var _a, _b, _c, _d, _e, _f;
        const json = (0, composer_1.getComposerJson)(fs, paths);
        return {
            files: (_c = (_b = (_a = json === null || json === void 0 ? void 0 : json.extra) === null || _a === void 0 ? void 0 : _a['flarum-cli']) === null || _b === void 0 ? void 0 : _b.excludeScaffolding) !== null && _c !== void 0 ? _c : [],
            configKeys: (_f = (_e = (_d = json === null || json === void 0 ? void 0 : json.extra) === null || _d === void 0 ? void 0 : _d['flarum-cli']) === null || _e === void 0 ? void 0 : _e.excludeScaffoldingConfigKeys) !== null && _f !== void 0 ? _f : {},
        };
    };
    const scaffolder = new scaffolder_1.Scaffolder((0, path_1.resolve)(__dirname, '../../boilerplate/skeleton/extension'), moduleStatusCache, excludeScaffoldingFunc);
    for (const name of exports.EXTENSION_MODULES) {
        scaffolder.registerModule(moduleNameToDef(name));
    }
    for (const name of exports.EXTENSION_PARAMS) {
        scaffolder.registerTemplateParam(paramNamesToDef(name));
    }
    cached = scaffolder;
    return scaffolder;
}
exports.genExtScaffolder = genExtScaffolder;
