"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonorepoCreate = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-await-in-loop */
const child_process_1 = require("child_process");
const monorepo_1 = require("../../utils/monorepo");
const cond_format_1 = require("boilersmith/utils/cond-format");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const fs_1 = require("fs");
const path_1 = require("path");
const os_1 = require("os");
const simple_git_1 = (0, tslib_1.__importDefault)(require("simple-git"));
const mem_fs_editor_1 = require("mem-fs-editor");
const commit_async_1 = require("boilersmith/utils/commit-async");
const validation_1 = require("../../utils/validation");
async function addGitPackage(cwd, path, remote, mainBranch = 'main') {
    const tmpDir = (0, fs_1.mkdtempSync)((0, path_1.resolve)((0, os_1.tmpdir)(), `${path.replace('/', '_')}-`));
    (0, child_process_1.execSync)(`git clone ${remote} ${tmpDir} --verbose --branch ${mainBranch} --single-branch`, { cwd });
    (0, child_process_1.execSync)(`git filter-repo --to-subdirectory-filter ${path}`, { cwd: tmpDir });
    if (mainBranch) {
        await (0, simple_git_1.default)(tmpDir).checkout(mainBranch);
    }
    await (0, simple_git_1.default)(tmpDir).branch(['REWRITE']);
    await (0, simple_git_1.default)(tmpDir).checkout('REWRITE');
    // Merge from remote
    const remoteName = path.replace('/', '_').replace('-', '_');
    await (0, simple_git_1.default)(cwd).addRemote(remoteName, tmpDir);
    (0, child_process_1.execSync)(`git fetch ${remoteName}`, { cwd });
    (0, child_process_1.execSync)(`git merge ${remoteName}/REWRITE --allow-unrelated-histories --no-edit`, { cwd });
    await (0, simple_git_1.default)(cwd).removeRemote(remoteName);
    (0, fs_1.rmSync)(tmpDir, { recursive: true, force: true });
}
function makeRunCommitStep(cwd, fs, io, paths, providers) {
    return async function (packagePaths, step, message) {
        for (const path of packagePaths) {
            await step.run(fs, paths.onMonorepoSub((0, path_1.resolve)(cwd, path), cwd), io, providers);
        }
        await (0, commit_async_1.commitAsync)(fs);
        await commitAll(cwd, message);
    };
}
async function getMonorepoConf(io, monorepoConfPath) {
    var _a;
    if (monorepoConfPath) {
        return JSON.parse((0, fs_1.readFileSync)(monorepoConfPath, 'utf8'));
    }
    const packages = { extensions: [], composer: [], npm: [] };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const confirm = await io.getParam({
            name: 'confirm',
            type: 'confirm',
            initial: true,
            message: 'Add another package to monorepo?',
        }, true);
        if (!confirm)
            break;
        const packageType = (await io.getParam({
            name: 'packageType',
            message: 'Package Type',
            type: 'select',
            choices: [
                { title: 'Flarum Extension', value: 'extensions' },
                { title: 'Composer PHP Package', value: 'composer' },
                { title: 'NPM JS/TS Package', value: 'npm' },
                { title: 'Flarum Core', value: 'core' },
            ],
            validate: (value) => value !== 'core' || !packages.core || 'A core package has already been specified.',
        }, true));
        const packageName = await io.getParam({
            name: 'name',
            message: 'Package Name (used to generate subdirectory path)',
            type: 'text',
            validate: validation_1.Validator.fileName,
        }, true);
        const gitRemote = await io.getParam({
            name: 'remote',
            message: 'Git remote (e.g. git@github.com:flarum/core.git)',
            type: 'text',
            validate: validation_1.Validator.gitRepo,
        }, true);
        const packageInfo = {
            name: packageName,
            gitRemote,
        };
        if (packageType === 'core') {
            packages.core = packageInfo;
        }
        else {
            const typePackages = (_a = packages[packageType]) !== null && _a !== void 0 ? _a : [];
            typePackages.push(packageInfo);
            packages[packageType] = typePackages;
        }
    }
    return { packages };
}
async function commitAll(cwd, message) {
    await (0, simple_git_1.default)(cwd).add('.');
    await (0, simple_git_1.default)(cwd).commit(message);
}
class MonorepoCreate {
    constructor(scaffolder, monorepoConfPath) {
        this.type = 'Create a monorepo of Flarum extensions';
        this.composable = false;
        this.exposes = [];
        this.scaffolder = scaffolder;
        this.monorepoConfPath = monorepoConfPath;
    }
    async run(fs, paths, io, providers) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const target = (_a = paths.requestedDir()) !== null && _a !== void 0 ? _a : paths.package('flarum_monorepo');
        const confirmTarget = await io.getParam({
            name: 'confirmTarget',
            message: `Create monorepo in directory: "${(0, cond_format_1.condFormat)(io.supportsAnsiColor, chalk_1.default.dim, target)}" (will be overwritten)?`,
            type: 'confirm',
            initial: true,
        });
        if (!confirmTarget) {
            io.error('Target not confirmed', true);
            return fs;
        }
        const conf = await getMonorepoConf(io, this.monorepoConfPath ? paths.cwd(this.monorepoConfPath) : undefined);
        const runCommitStep = makeRunCommitStep(target, fs, io, paths, providers);
        (0, fs_1.rmSync)(target, { recursive: true, force: true });
        (0, fs_1.mkdirSync)(target);
        await (0, simple_git_1.default)(target).init();
        for (const lib of (_b = conf.packages.npm) !== null && _b !== void 0 ? _b : []) {
            await addGitPackage(target, (0, monorepo_1.npmPath)(lib.name), lib.gitRemote, lib.mainBranch);
        }
        for (const lib of (_c = conf.packages.composer) !== null && _c !== void 0 ? _c : []) {
            await addGitPackage(target, (0, monorepo_1.composerPath)(lib.name), lib.gitRemote, lib.mainBranch);
        }
        for (const ext of (_d = conf.packages.extensions) !== null && _d !== void 0 ? _d : []) {
            await addGitPackage(target, (0, monorepo_1.extensionPath)(ext.name), ext.gitRemote, ext.mainBranch);
        }
        const corePkg = conf.packages.core;
        if (corePkg) {
            await addGitPackage(target, (0, monorepo_1.corePath)(corePkg.name), corePkg.gitRemote, corePkg.mainBranch);
        }
        const npmPaths = (_f = (_e = conf.packages.npm) === null || _e === void 0 ? void 0 : _e.map((lib) => (0, monorepo_1.npmPath)(lib.name))) !== null && _f !== void 0 ? _f : [];
        const composerPaths = (_h = (_g = conf.packages.composer) === null || _g === void 0 ? void 0 : _g.map((lib) => (0, monorepo_1.composerPath)(lib.name))) !== null && _h !== void 0 ? _h : [];
        const flarumPaths = (_k = (_j = conf.packages.extensions) === null || _j === void 0 ? void 0 : _j.map((ext) => (0, monorepo_1.extensionPath)(ext.name))) !== null && _k !== void 0 ? _k : [];
        if (corePkg) {
            flarumPaths.push((0, monorepo_1.corePath)(corePkg.name));
        }
        flarumPaths.forEach((path) => {
            (0, fs_1.rmSync)((0, path_1.resolve)(target, path, '.github'), { force: true, recursive: true });
        });
        [...npmPaths, ...composerPaths, ...flarumPaths].forEach((path) => {
            (0, fs_1.rmSync)((0, path_1.resolve)(target, path, '.styleci.yml'), { force: true });
        });
        await commitAll(target, [
            'chore: remove centralizable repo config',
            '- Remove .github conf folder from Flarum packages',
            '- Remove styleci config from all packages',
        ]);
        (0, mem_fs_editor_1.create)(fs).writeJSON((0, path_1.resolve)(target, 'flarum-monorepo.json'), conf);
        await (0, commit_async_1.commitAsync)(fs);
        await commitAll(target, 'chore: add monorepo config file');
        [...composerPaths, ...flarumPaths].forEach((path) => {
            const cwd = (0, path_1.resolve)(target, path);
            const relRepoPath = path.includes('/') ? '../../*/*' : './../*/*';
            (0, child_process_1.execSync)(`composer config repositories.0 path "${relRepoPath}"`, { cwd });
            (0, child_process_1.execSync)('composer config minimum-stability dev', { cwd });
            (0, child_process_1.execSync)('composer config prefer-stable true', { cwd });
            const composerJsonPath = (0, path_1.resolve)(cwd, 'composer.json');
            const composerJson = (0, fs_1.readFileSync)(composerJsonPath);
            (0, fs_1.writeFileSync)(composerJsonPath, composerJson.toString().replace('"dev-master": "1.x-dev"', '"dev-main": "1.x-dev"'));
        });
        [...composerPaths, ...flarumPaths].forEach((path) => {
            const cwd = (0, path_1.resolve)(target, path);
            (0, child_process_1.execSync)('composer install --dry-run --no-interaction --no-ansi --no-progress --no-scripts --no-autoloader', { cwd });
        });
        await commitAll(target, 'chore: set up composer path repos');
        (0, mem_fs_editor_1.create)(fs).writeJSON((0, path_1.resolve)(target, 'flarum-monorepo.json'), conf);
        await (0, commit_async_1.commitAsync)(fs);
        await commitAll(target, 'chore: add monorepo config file');
        await runCommitStep(flarumPaths, this.scaffolder.genAuditStep(false), 'chore: flarum-cli audit infra --fix');
        return fs;
    }
    getExposed() {
        return {};
    }
}
exports.MonorepoCreate = MonorepoCreate;
