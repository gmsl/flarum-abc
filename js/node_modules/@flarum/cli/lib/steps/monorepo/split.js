"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonorepoSplit = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path_1 = require("path");
const simple_git_1 = (0, tslib_1.__importDefault)(require("simple-git"));
const monorepo_1 = require("../../utils/monorepo");
async function addRemote(cwd, name, remote) {
    try {
        await (0, simple_git_1.default)(cwd).addRemote(name, remote);
        await (0, simple_git_1.default)(cwd).fetch(name);
    }
    catch (_a) {
        // ignore, remote already exists.
    }
}
async function splitAndPush(cwd, splitExecPath, splitPath, remoteName, remoteBranch, force = false) {
    const currBranch = (0, child_process_1.execSync)('git rev-parse --abbrev-ref HEAD', { cwd }).toString().trim();
    const sha1 = (0, child_process_1.execSync)(`${splitExecPath} --prefix=${splitPath}`, { cwd, stdio: ['pipe', 'pipe', 'ignore'] })
        .toString()
        .trim();
    const branch = remoteBranch || 'main';
    const pushArgs = `${remoteName} "${sha1}:refs/heads/${branch}"`;
    if (force) {
        (0, child_process_1.execSync)(`git push --force ${pushArgs}`, { cwd });
    }
    else {
        const tmpBranch = `${remoteName}-tmp`;
        (0, child_process_1.execSync)(`git switch -c ${tmpBranch} ${sha1}`, { cwd });
        (0, child_process_1.execSync)(`git pull ${remoteName} ${branch} --rebase`, { cwd });
        (0, child_process_1.execSync)(`git push ${pushArgs}`, { cwd });
        (0, child_process_1.execSync)(`git switch ${currBranch}`, { cwd });
    }
}
async function cleanupBranchAndRemote(cwd, name) {
    await (0, simple_git_1.default)(cwd).removeRemote(name);
    const tmpBranch = `${name}-tmp`;
    (0, child_process_1.execSync)(`git branch -D ${tmpBranch}`, { cwd });
}
class MonorepoSplit {
    constructor(force) {
        this.type = 'Split monorepo changes to the respective cloned repos.';
        this.composable = false;
        this.exposes = [];
        this.force = force;
    }
    async run(fs, paths, io, _providers) {
        var _a, _b, _c, _d;
        const platform = process.platform;
        if (platform !== 'linux' && platform !== 'darwin') {
            io.error(`Your platform, "${platform}", is not supported. Split can only be run on linux and mac`, true);
            return fs;
        }
        if (this.force && !(await io.getParam({ type: 'confirm', name: 'confirm', initial: false, message: 'Are you sure you want to force split?' }))) {
            io.error('Decided not to force push', true);
            return fs;
        }
        const splitExec = (0, path_1.resolve)(__dirname, `../../../bin/splitsh-lite-${platform}`);
        const target = (_a = paths.requestedDir()) !== null && _a !== void 0 ? _a : paths.package();
        await (0, simple_git_1.default)(target).pull();
        const conf = (0, monorepo_1.getMonorepoConf)(fs, paths);
        const corePkg = conf.packages.core;
        const clean = [];
        // Add Remotes
        for (const lib of (_b = conf.packages.npm) !== null && _b !== void 0 ? _b : []) {
            await addRemote(target, lib.name, lib.gitRemote);
            await splitAndPush(target, splitExec, (0, monorepo_1.npmPath)(lib.name), lib.name, lib.mainBranch, this.force);
            clean.push(lib.name);
        }
        for (const lib of (_c = conf.packages.composer) !== null && _c !== void 0 ? _c : []) {
            await addRemote(target, lib.name, lib.gitRemote);
            await splitAndPush(target, splitExec, (0, monorepo_1.composerPath)(lib.name), lib.name, lib.mainBranch, this.force);
            clean.push(lib.name);
        }
        for (const ext of (_d = conf.packages.extensions) !== null && _d !== void 0 ? _d : []) {
            await addRemote(target, ext.name, ext.gitRemote);
            await splitAndPush(target, splitExec, (0, monorepo_1.extensionPath)(ext.name), ext.name, ext.mainBranch, this.force);
            clean.push(ext.name);
        }
        if (corePkg) {
            await addRemote(target, corePkg.name, corePkg.gitRemote);
            await splitAndPush(target, splitExec, (0, monorepo_1.corePath)(corePkg.name), corePkg.name, corePkg.mainBranch, this.force);
            clean.push(corePkg.name);
        }
        for (const name of clean) {
            await cleanupBranchAndRemote(target, name);
        }
        return fs;
    }
    getExposed() {
        throw new Error('Method not implemented.');
    }
}
exports.MonorepoSplit = MonorepoSplit;
