"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationType = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const cli_ux_1 = (0, tslib_1.__importDefault)(require("cli-ux"));
const path_1 = require("path");
const globby_1 = (0, tslib_1.__importDefault)(require("globby"));
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const io_1 = require("boilersmith/io");
const step_manager_1 = require("boilersmith/step-manager");
const paths_1 = require("boilersmith/paths");
const php_provider_1 = require("./providers/php-provider");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const errors_1 = require("@oclif/errors");
const monorepo_1 = require("./utils/monorepo");
const mem_fs_1 = require("mem-fs");
var LocationType;
(function (LocationType) {
    LocationType[LocationType["FLARUM_EXTENSION"] = 0] = "FLARUM_EXTENSION";
    LocationType[LocationType["FLARUM_CORE"] = 1] = "FLARUM_CORE";
    LocationType[LocationType["FLARUM_MONOREPO"] = 2] = "FLARUM_MONOREPO";
})(LocationType = exports.LocationType || (exports.LocationType = {}));
class BaseCommand extends core_1.Command {
    constructor() {
        super(...arguments);
        this.STUB_PATH = (0, path_1.resolve)(__dirname, '../boilerplate/stubs/');
        this.dry = false;
        this.requireExistingExtension = true;
    }
    async run() {
        const { args, flags } = await this.parse(this.constructor);
        this.args = args;
        this.flags = flags;
        const path = args.path;
        const welcomeMessage = this.welcomeMessage();
        if (welcomeMessage) {
            this.log(welcomeMessage);
        }
        let extRoot;
        if (this.requireExistingExtension) {
            const rootData = await this.getFlarumExtensionRoot(path || process.cwd());
            extRoot = rootData.path;
            this.locationType = rootData.type;
            await this.confirmExtDir(extRoot);
        }
        else {
            extRoot = path || process.cwd();
        }
        await this.additionalPreRunChecks(extRoot);
        const paths = new paths_1.NodePaths({
            requestedDir: path,
            package: extRoot,
        });
        const phpProvider = new php_provider_1.PhpSubsystemProvider((0, path_1.resolve)(__dirname, '../php-subsystem/index.php'));
        const out = await this.steps(new step_manager_1.StepManager(), extRoot).run(paths, this.genIO(), { php: phpProvider }, this.dry);
        const errorMessages = out.messages.filter((m) => m.type === 'error');
        this.log('\n\n');
        if (out.succeeded && errorMessages.length === 0) {
            this.log(chalk_1.default.bold(chalk_1.default.underline(chalk_1.default.green('Success! The following steps were completed:'))));
        }
        else if (out.succeeded) {
            this.log(chalk_1.default.bold(chalk_1.default.underline(chalk_1.default.yellow('All steps completed, but with some errors:'))));
            for (const message of errorMessages) {
                this.log(chalk_1.default.dim(chalk_1.default.red(message.message)));
            }
            this.log(chalk_1.default.bold(chalk_1.default.yellow('The steps that completed were:')));
        }
        else if (out.error.startsWith('EEXIT:')) {
            this.log(chalk_1.default.bold(chalk_1.default.underline(chalk_1.default.red('Exiting.'))));
            if (out.stepsRan.length > 0) {
                this.log(chalk_1.default.bold(chalk_1.default.yellow('Before the exit, the following steps were completed:')));
            }
        }
        else {
            this.log(chalk_1.default.bold(chalk_1.default.underline(chalk_1.default.red('Error occurred, and could not complete:'))));
            this.log(chalk_1.default.red(out.error));
            if (out.errorTrace) {
                this.log(chalk_1.default.dim(chalk_1.default.red(out.errorTrace)));
            }
            if (out.stepsRan.length > 0) {
                this.log('');
                this.log(chalk_1.default.bold(chalk_1.default.yellow('Before the error, the following steps were completed:')));
            }
        }
        for (const stepName of out.stepsRan)
            this.log(`- ${chalk_1.default.dim(stepName)}`);
        this.log('');
        const nonErrorMessages = out.messages.filter((m) => m.type !== 'error');
        if (nonErrorMessages.length > 0) {
            this.log('');
            this.log('The following messages were generated during execution:');
            for (const message of nonErrorMessages) {
                this.log(message.message);
            }
        }
        if (!out.succeeded || errorMessages.length > 0) {
            this.exit(1);
        }
        const goodbyeMessage = this.goodbyeMessage();
        if (goodbyeMessage) {
            this.log(goodbyeMessage);
        }
    }
    welcomeMessage() {
        return '';
    }
    goodbyeMessage() {
        return 'Please make sure to check my work, adjust formatting, and test before committing!!!';
    }
    async additionalPreRunChecks(_extRoot) {
        // Can be implemented if needed.
    }
    // ----------------------------------------------------------------
    // Confirmation
    // ----------------------------------------------------------------
    genIO() {
        return new io_1.PromptsIO({}, [], this.flags['no-interaction'], errors_1.exit);
    }
    monorepoPaths(options) {
        var _a, _b;
        try {
            const monorepoConfig = (0, monorepo_1.getMonorepoConf)((0, mem_fs_1.create)(), new paths_1.NodePaths({ package: process.cwd() }));
            return [
                ...(options.includeCore && monorepoConfig.packages.core ? [(0, monorepo_1.corePath)(monorepoConfig.packages.core.name)] : []),
                ...(options.includeExtensions ? monorepoConfig.packages.extensions : []).map((ext) => (0, monorepo_1.extensionPath)(ext.name)),
                ...(options.includePhpPackages ? (_a = monorepoConfig.packages.composer) !== null && _a !== void 0 ? _a : [] : []).map((lib) => (0, monorepo_1.composerPath)(lib.name)),
                ...(options.includeJSPackages ? (_b = monorepoConfig.packages.npm) !== null && _b !== void 0 ? _b : [] : []).map((lib) => (0, monorepo_1.npmPath)(lib.name)),
            ];
        }
        catch (_c) {
            this.error('Could not run monorepo command: `flarum-monorepo.json` file is missing or invalid.');
        }
    }
    isFlarumMonorepo(path) {
        return (0, fs_1.existsSync)((0, path_1.resolve)(path, 'flarum-monorepo.json'));
    }
    isFlarumCore(path) {
        try {
            const composerJsonPath = (0, path_1.resolve)(path, 'composer.json');
            const val = JSON.parse((0, fs_1.readFileSync)(composerJsonPath, 'utf8'));
            return val.name === 'flarum/core';
        }
        catch (_a) {
            return false;
        }
    }
    jsPackageManager(currDir) {
        if (!(0, fs_1.existsSync)((0, path_1.resolve)(currDir, 'js')))
            return null;
        return (0, fs_1.existsSync)((0, path_1.resolve)(currDir, 'js/yarn.lock')) ? 'yarn' : 'npm';
    }
    async getFlarumExtensionRoot(currDir) {
        let currPath = (0, path_1.resolve)(currDir);
        while (currPath !== '/') {
            if ((0, fs_1.existsSync)((0, path_1.resolve)(currPath, 'flarum-monorepo.json'))) {
                return { path: currPath, type: LocationType.FLARUM_MONOREPO };
            }
            if ((0, fs_1.existsSync)((0, path_1.resolve)(currPath, 'composer.json')) && (0, fs_1.existsSync)((0, path_1.resolve)(currPath, 'extend.php'))) {
                return { path: currPath, type: LocationType.FLARUM_EXTENSION };
            }
            if (this.isFlarumCore(currPath)) {
                return { path: currPath, type: LocationType.FLARUM_CORE };
            }
            currPath = (0, path_1.resolve)(currPath, '..');
        }
        this.error(`${(0, path_1.resolve)(currDir)} is not located in a valid Flarum package!
- Flarum extensions must contain (at a minimum) 'extend.php' and 'composer.json' files.
- Flarum core must contain a 'composer.json' file with the name 'flarum/core'.
- Flarum monorepos must have a valid 'flarum-monorepo.json' file`);
    }
    async confirmExtDir(extRoot) {
        const verify = await this.genIO().getParam({
            name: 'verify',
            type: 'confirm',
            message: `Work in Flarum package located at ${(0, path_1.resolve)(extRoot)}?`,
            initial: true,
        });
        if (!verify)
            this.exit();
    }
    async ensureComposerInstallRan(extRoot) {
        if ((0, fs_1.existsSync)((0, path_1.resolve)(extRoot, 'vendor/flarum/core/composer.json')))
            return;
        this.log("This command requires `composer install` to have been ran in your extension's root directory.");
        const composer = await this.genIO().getParam({
            name: 'composer',
            type: 'confirm',
            message: 'Would you like me to take care of that for you?',
            initial: true,
        });
        if (composer) {
            cli_ux_1.default.action.start('Installing composer packages');
            (0, child_process_1.execSync)('composer install', { cwd: extRoot });
            cli_ux_1.default.action.stop();
        }
        else {
            this.error("Run `composer install` in your extension's root directory, then try again.");
        }
    }
    /**
     * If false, files do not exist so no need to override.
     * If true, files should be overriden.
     * If user says no, will exit and not return anything.
     */
    async confirmOverrideFiles(dir, pattern, confirmationMessage) {
        const paths = Array.isArray(pattern) ? pattern : [pattern];
        const files = await (0, globby_1.default)(paths.map((p) => (0, path_1.resolve)(dir, p)));
        const empty = files.length === 0 || (files.length === 1 && files[0] === '.git');
        if (empty)
            return false;
        const overwrite = await this.genIO().getParam({
            name: 'overwrite',
            type: 'confirm',
            message: confirmationMessage,
            initial: true,
        });
        if (overwrite === false)
            this.exit();
        return true;
    }
    async deleteFiles(dir, pattern) {
        const pathsToDelete = await (0, globby_1.default)((0, path_1.resolve)(dir, pattern));
        pathsToDelete.forEach(fs_1.unlinkSync);
    }
}
exports.default = BaseCommand;
BaseCommand.flags = {
    'no-interaction': core_1.Flags.boolean({
        char: 'n',
        description: 'Do not ask any interactive questions, assume defaults. When impossible, error.',
        default: false,
    }),
    help: core_1.Flags.help({ char: 'h' }),
};
BaseCommand.args = [
    {
        name: 'path',
        description: 'Where should this command be executed?',
    },
];
