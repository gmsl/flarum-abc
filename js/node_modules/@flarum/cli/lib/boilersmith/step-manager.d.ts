import { Store } from 'mem-fs';
import { ExposedParamManager } from './exposed-param-manager';
import { IO, Message } from './io';
import { Paths } from './paths';
export declare type DefaultProviders = {};
export interface Step<Providers extends DefaultProviders = DefaultProviders, Exposes extends string = string> {
    /**
     * A short string describing what the step does.
     */
    type: string;
    /**
     * Can this step be composed with other steps?
     *
     * This is the case if the step makes no changes to the disk filesystem while running.
     */
    composable: boolean;
    /**
     * A list of names of params that this step exposes to other steps.
     */
    exposes: Exposes[];
    run: (fs: Store, paths: Paths, io: IO, providers: Providers) => Promise<Store>;
    /**
     * Return an object of exposed params.
     *
     * The paths and io will be the same objects provided to the `run` method.
     */
    getExposed(paths: Paths, io: IO): Record<Exposes, unknown>;
}
interface ShouldRunConfig {
    optional?: boolean;
    confirmationMessage?: string;
    default?: boolean;
}
interface StoredStep<Providers extends DefaultProviders> {
    name?: string;
    step: Step<Providers>;
    shouldRun: ShouldRunConfig;
    dependencies: StepDependency[];
    predefinedParams: PredefinedParameters;
    mapPaths: string[];
}
interface StepDependency {
    sourceStep: string;
    exposedName: string;
    consumedName?: string;
    dontRunIfFalsy?: boolean;
    modifier?: (value: unknown) => string;
}
declare type PredefinedParameters = Record<string, unknown>;
declare type StepsResult = {
    succeeded: true;
    messages: Message[];
    stepsRan: string[];
} | {
    succeeded: false;
    error: string;
    errorTrace?: string;
    messages: Message[];
    stepsRan: string[];
};
export declare class StepManager<Providers extends DefaultProviders> {
    protected steps: Array<StoredStep<Providers> | AtomicStepManager<Providers>>;
    protected namedSteps: Map<string, StoredStep<Providers>>;
    protected exposedParams: ExposedParamManager;
    /**
     * A step is an incremental operation that updates the filesystem.
     */
    step(step: Step<Providers>, shouldRun?: ShouldRunConfig, dependencies?: StepDependency[], predefinedParams?: PredefinedParameters, mapPaths?: string[]): this;
    namedStep(name: string, step: Step<Providers>, shouldRun?: ShouldRunConfig, dependencies?: StepDependency[], predefinedParams?: PredefinedParameters, mapPaths?: string[]): this;
    atomicGroup(callback: (stepManager: AtomicStepManager<Providers>) => void): this;
    protected validateDependencies(step: Step<Providers>, dependencies: StepDependency[], mapPaths: string[]): void;
    run(paths: Paths, io: IO, providers: Providers, dry?: boolean): Promise<StepsResult>;
    protected stepShouldRun(storedStep: StoredStep<Providers>, io: IO, packagePath?: string): Promise<boolean>;
    protected runStep(storedStep: StoredStep<Providers>, paths: Paths, io: IO, providers: Providers, packagePath?: string, fs?: Store): Promise<Store>;
}
export declare class AtomicStepManager<Providers = DefaultProviders> extends StepManager<Providers> {
    protected steps: StoredStep<Providers>[];
    constructor(parentNamedSteps?: Map<string, StoredStep<Providers>>, parentExposedParams?: ExposedParamManager);
    step(step: Step<Providers>, shouldRun?: ShouldRunConfig, dependencies?: StepDependency[], predefinedParams?: PredefinedParameters, mapPaths?: string[]): this;
    namedStep(name: string, step: Step<Providers>, shouldRun?: ShouldRunConfig, dependencies?: StepDependency[], predefinedParams?: PredefinedParameters, mapPaths?: string[]): this;
    atomicGroup(_callback: (stepManager: AtomicStepManager<Providers>) => void): this;
    run(paths: Paths, io: IO, providers: Providers, dry?: boolean): Promise<StepsResult>;
}
export {};
