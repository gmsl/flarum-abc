"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AtomicStepManager = exports.StepManager = void 0;
/* eslint-disable no-await-in-loop */
const mem_fs_1 = require("mem-fs");
const exposed_param_manager_1 = require("./exposed-param-manager");
const commit_async_1 = require("./utils/commit-async");
const formatDependencies = (strings) => strings.map((s) => `"${s}"`).join(', ');
class StepManager {
    constructor() {
        this.steps = [];
        this.namedSteps = new Map();
        this.exposedParams = new exposed_param_manager_1.ExposedParamManager();
    }
    /**
     * A step is an incremental operation that updates the filesystem.
     */
    step(step, shouldRun = {}, dependencies = [], predefinedParams = {}, mapPaths = []) {
        this.validateDependencies(step, dependencies, mapPaths);
        this.steps = [...this.steps, { step, shouldRun, dependencies, predefinedParams, mapPaths }];
        return this;
    }
    namedStep(name, step, shouldRun = {}, dependencies = [], predefinedParams = {}, mapPaths = []) {
        if (this.namedSteps.has(name)) {
            throw new Error(`Named steps must have unique names. A step with name "${name}" already exists.`);
        }
        this.validateDependencies(step, dependencies, mapPaths);
        const newStep = { name, step, shouldRun, dependencies, predefinedParams, mapPaths };
        this.steps = [...this.steps, newStep];
        this.namedSteps.set(name, newStep);
        return this;
    }
    atomicGroup(callback) {
        const atomicCollection = new AtomicStepManager(this.namedSteps, this.exposedParams);
        callback(atomicCollection);
        this.steps = [...this.steps, atomicCollection];
        return this;
    }
    validateDependencies(step, dependencies, mapPaths) {
        const missingDependencySteps = dependencies.map((dep) => dep.sourceStep).filter((stepName) => !this.namedSteps.has(stepName));
        if (missingDependencySteps.length > 0) {
            throw new Error(`Step of type "${step.type}" depends on nonexistent named steps ${formatDependencies(missingDependencySteps)}`);
        }
        const missingDependencyParams = [];
        const missingDependencyParamSteps = [];
        for (const dependency of dependencies) {
            const sourceStep = this.namedSteps.get(dependency.sourceStep);
            if (!(sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.step.exposes.includes(dependency.exposedName)) && dependency.exposedName !== '__succeeded') {
                missingDependencyParamSteps.push(sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.name);
                missingDependencyParams.push(dependency.exposedName);
            }
            if (mapPaths.length === 0 && (sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.mapPaths.length)) {
                throw new Error(`Non path-mapped step of type "${step.type}" may not depend on path-mapped step "${sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.name}".`);
            }
            const missingMapPathsDeps = mapPaths.filter((p) => sourceStep && !sourceStep.mapPaths.includes(p));
            if (sourceStep && (missingMapPathsDeps === null || missingMapPathsDeps === void 0 ? void 0 : missingMapPathsDeps.length) && sourceStep.mapPaths.length > 0) {
                throw new Error(`Step of type "${step.type}" (A) depends on named step: "${sourceStep.name}" (B), but is mapped across some paths that (B) is not: "${missingMapPathsDeps.join(', ')}"`);
            }
        }
        if (missingDependencyParamSteps.length > 0) {
            throw new Error(`Step of type "${step.type}" depends on nonexistent exposed params ${formatDependencies(missingDependencyParams)} from named steps ${formatDependencies(missingDependencyParamSteps)}`);
        }
    }
    async run(paths, io, providers, dry = false) {
        if (dry && this.steps.some((s) => !(s instanceof AtomicStepManager) && !s.step.composable)) {
            throw new Error('Cannot dry run, as this step manager has non-composable steps.');
        }
        const stepNames = [];
        const checkAndRun = async (step, packagePath) => {
            const shouldRun = await this.stepShouldRun(step, io, packagePath);
            if (!shouldRun)
                return;
            const fs = await this.runStep(step, paths, io, providers, packagePath);
            if (!dry) {
                await (0, commit_async_1.commitAsync)(fs);
            }
            stepNames.push(packagePath ? `${step.step.type} (${packagePath})` : step.step.type);
        };
        try {
            for (const storedStep of this.steps) {
                if (storedStep instanceof AtomicStepManager) {
                    const res = await storedStep.run(paths, io, providers);
                    if (!res.succeeded) {
                        throw new Error(res.error);
                    }
                    stepNames.push(...res.stepsRan);
                }
                else if (storedStep.mapPaths.length > 0) {
                    for (const path of storedStep.mapPaths) {
                        await checkAndRun(storedStep, path);
                    }
                }
                else {
                    await checkAndRun(storedStep);
                }
            }
        }
        catch (error) {
            return {
                succeeded: false,
                error: error instanceof Error ? error.message : String(error),
                errorTrace: error instanceof Error ? error.stack : undefined,
                stepsRan: stepNames,
                messages: io.getOutput(),
            };
        }
        return {
            succeeded: true,
            stepsRan: stepNames,
            messages: io.getOutput(),
        };
    }
    async stepShouldRun(storedStep, io, packagePath) {
        let allDependenciesRan = true;
        let noRequiredNonFalsyDependenciesAreFalsy = true;
        for (const dep of storedStep.dependencies) {
            const sourceStep = this.namedSteps.get(dep.sourceStep);
            const sourcePackagePath = (sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.mapPaths.length) ? packagePath : undefined;
            if (!this.exposedParams.stepRan(dep.sourceStep, sourcePackagePath))
                allDependenciesRan = false;
            if (dep.exposedName !== '__succeeded' && dep.dontRunIfFalsy && !this.exposedParams.get(dep.sourceStep, dep.exposedName, sourcePackagePath)) {
                noRequiredNonFalsyDependenciesAreFalsy = false;
            }
        }
        if (!allDependenciesRan || !noRequiredNonFalsyDependenciesAreFalsy)
            return false;
        if (!storedStep.shouldRun.optional)
            return true;
        const promptConfirm = await io.newInstance({ context: 'Confirm Step' }, []).getParam({
            name: 'execute_step',
            message: storedStep.shouldRun.confirmationMessage || `Run step of type "${storedStep.step.type}"?`,
            initial: storedStep.shouldRun.default || false,
            type: 'confirm',
        });
        return promptConfirm;
    }
    async runStep(storedStep, paths, io, providers, packagePath, fs = (0, mem_fs_1.create)()) {
        const initial = storedStep.dependencies.reduce((initial, dep) => {
            const sourceStep = this.namedSteps.get(dep.sourceStep);
            let depValue;
            depValue =
                dep.exposedName === '__succeeded'
                    ? this.exposedParams.stepRan(dep.sourceStep, packagePath)
                    : this.exposedParams.get(dep.sourceStep, dep.exposedName, (sourceStep === null || sourceStep === void 0 ? void 0 : sourceStep.mapPaths.length) ? packagePath : undefined);
            if (dep.modifier) {
                depValue = dep.modifier(depValue);
            }
            initial[dep.consumedName || dep.exposedName] = depValue;
            return initial;
        }, {});
        const cloned = io.newInstance(Object.assign(Object.assign({}, initial), storedStep.predefinedParams), io.getOutput());
        const stepPaths = packagePath ? paths.onMonorepoSub(packagePath) : paths;
        const newFs = await storedStep.step.run(fs, stepPaths, cloned, providers);
        if (storedStep.name) {
            this.exposedParams.add(storedStep.name, storedStep.step.getExposed(stepPaths, io), packagePath);
        }
        return newFs;
    }
}
exports.StepManager = StepManager;
class AtomicStepManager extends StepManager {
    constructor(parentNamedSteps = new Map(), parentExposedParams = new exposed_param_manager_1.ExposedParamManager()) {
        super();
        this.steps = [];
        this.namedSteps = parentNamedSteps;
        this.exposedParams = parentExposedParams;
    }
    step(step, shouldRun = {}, dependencies = [], predefinedParams = {}, mapPaths = []) {
        if (!step.composable) {
            throw new Error(`Step of type "${step.type}" is not composable, and cannot be added to an atomic group.`);
        }
        return super.step(step, shouldRun, dependencies, predefinedParams, mapPaths);
    }
    namedStep(name, step, shouldRun = {}, dependencies = [], predefinedParams = {}, mapPaths = []) {
        if (!step.composable) {
            throw new Error(`Step of type "${step.type}" is not composable, and cannot be added to an atomic group.`);
        }
        return super.namedStep(name, step, shouldRun, dependencies, predefinedParams, mapPaths);
    }
    atomicGroup(_callback) {
        throw new Error("Atomic groups can't be nested.");
    }
    async run(paths, io, providers, dry = false) {
        let fs = (0, mem_fs_1.create)();
        const checkAndRun = async (step, packagePath) => {
            const shouldRun = await this.stepShouldRun(step, io, packagePath);
            if (!shouldRun)
                return;
            fs = await this.runStep(step, paths, io, providers, packagePath, fs);
            stepNames.push(packagePath ? `${step.step.type} (${packagePath})` : step.step.type);
        };
        const stepNames = [];
        try {
            for (const storedStep of this.steps) {
                if (storedStep.mapPaths.length > 0) {
                    for (const path of storedStep.mapPaths) {
                        await checkAndRun(storedStep, path);
                    }
                }
                else {
                    await checkAndRun(storedStep);
                }
            }
        }
        catch (error) {
            return {
                error: error instanceof Error ? error.message : String(error),
                errorTrace: error instanceof Error ? error.stack : undefined,
                succeeded: false,
                stepsRan: [],
                messages: io.getOutput(),
            };
        }
        if (!dry) {
            await (0, commit_async_1.commitAsync)(fs);
        }
        return {
            succeeded: true,
            stepsRan: stepNames,
            messages: io.getOutput(),
        };
    }
}
exports.AtomicStepManager = AtomicStepManager;
