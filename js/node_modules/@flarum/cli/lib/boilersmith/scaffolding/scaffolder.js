"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scaffolder = void 0;
const tslib_1 = require("tslib");
const globby_1 = (0, tslib_1.__importDefault)(require("globby"));
const path_1 = require("path");
const json_leaf_paths_1 = require("boilersmith/utils/json-leaf-paths");
const read_tpl_1 = require("boilersmith/utils/read-tpl");
const init_step_factory_1 = require("./init-step-factory");
const module_1 = require("./module");
const template_param_1 = require("./template-param");
const infra_step_factory_1 = require("./infra-step-factory");
const rename_keys_1 = require("boilersmith/utils/rename-keys");
const clone_and_fill_1 = require("boilersmith/utils/clone-and-fill");
const audit_step_factory_1 = require("./audit-step-factory");
class Scaffolder {
    constructor(scaffoldDir, moduleStatusCache, excludeScaffoldingFunc) {
        this.templateParams = [];
        this.modules = [];
        this.scaffoldDir = scaffoldDir;
        this.moduleStatusCache = moduleStatusCache;
        this.excludeScaffoldingFunc = excludeScaffoldingFunc;
    }
    registerModule(module) {
        this.modules.push(module);
        return this;
    }
    registerTemplateParam(templateParam) {
        if ((0, template_param_1.isComputedParam)(templateParam)) {
            const currParams = new Set(this.templateParams.map((p) => (0, template_param_1.getParamName)(p)));
            const missingDeps = templateParam.uses.filter((dep) => !currParams.has(dep));
            if (missingDeps.length > 0) {
                throw new Error(`Computed template param "${(0, template_param_1.getParamName)(templateParam)}" is missing dependency params: "${missingDeps.join(', ')}".`);
            }
        }
        this.templateParams.push(templateParam);
        return this;
    }
    genInitStep() {
        return (0, init_step_factory_1.initStepFactory)(this.scaffoldDir, this.modules, this.templateParams, this.excludeScaffoldingFunc, this.moduleStatusCache);
    }
    genInfraStep(module) {
        return (0, infra_step_factory_1.infraStepFactory)(this.scaffoldDir, module, this.modules, this.templateParams, this.excludeScaffoldingFunc, this.moduleStatusCache);
    }
    genAuditStep(dry = true) {
        return (0, audit_step_factory_1.auditStepFactory)(dry, this.scaffoldDir, this.modules, this.templateParams, this.excludeScaffoldingFunc, this.moduleStatusCache);
    }
    async templateParamVal(param, fs, paths, io) {
        return (await (0, template_param_1.currParamValues)(this.templateParams, fs, paths, io))[param];
    }
    async templateParamVals(fs, paths, io) {
        return (0, template_param_1.currParamValues)(this.templateParams, fs, paths, io);
    }
    async modulesEnabled(fs, paths) {
        return (0, module_1.currModulesEnabled)(this.modules, fs, paths, this.moduleStatusCache);
    }
    moduleFiles(moduleName) {
        var _a, _b;
        return (_b = (_a = this.modules.find((m) => m.name === moduleName)) === null || _a === void 0 ? void 0 : _a.filesToReplace.map((f) => (typeof f === 'string' ? f : f.path))) !== null && _b !== void 0 ? _b : [];
    }
    /**
     * Confirm that all files and configuration keys in the scaffolding dir
     * are owned by at least one module, and that no modules own nonexistent
     * files or configuration keys.
     */
    async validate() {
        const errors = [];
        // Generate template data for future checks
        const paramVals = Object.fromEntries(this.templateParams.map((param) => [(0, template_param_1.getParamName)(param), 'TEST']));
        const modulesEnabled = Object.fromEntries(this.modules.map((module) => [module.name, true]));
        const tplData = { params: paramVals, modules: modulesEnabled };
        const tplDataFlat = Object.assign(Object.assign({}, (0, rename_keys_1.renameKeys)(tplData.modules, (k) => `modules.${k}`)), (0, rename_keys_1.renameKeys)(tplData.params, (k) => `params.${k}`));
        const moduleNames = new Set(this.modules.map((m) => m.name));
        for (const module of this.modules) {
            const missingDeps = module.togglable ? module.dependsOn.filter((dep) => !moduleNames.has(dep)) : [];
            if (missingDeps.length > 0) {
                errors.push(`Module "${module.name}" depends on modules that are not registered: "${missingDeps.join(', ')}".`);
            }
        }
        const filesToOwnerModules = new Map();
        const configKeysToOwnerModules = new Map();
        const templateParamsToUsingModules = new Map();
        for (const module of this.modules) {
            module.filesToReplace.forEach((file) => {
                var _a;
                const path = typeof file === 'string' ? file : file.path;
                const currModules = (_a = filesToOwnerModules.get(path)) !== null && _a !== void 0 ? _a : [];
                filesToOwnerModules.set(path, [...currModules, module.name]);
            });
            module.needsTemplateParams.forEach((paramName) => {
                var _a;
                const currModules = (_a = filesToOwnerModules.get(paramName)) !== null && _a !== void 0 ? _a : [];
                templateParamsToUsingModules.set(paramName, [...currModules, module.name]);
            });
            Object.keys(module.jsonToAugment).forEach((jsonPath) => {
                var _a;
                const ownedKeys = (0, clone_and_fill_1.cloneAndFill)(module.jsonToAugment, tplDataFlat)[jsonPath];
                const currJsonData = (_a = configKeysToOwnerModules.get(jsonPath)) !== null && _a !== void 0 ? _a : { fileOwners: [], keyOwners: new Map() };
                currJsonData.fileOwners.push(module.name);
                ownedKeys.forEach((key) => {
                    var _a;
                    const currModules = (_a = currJsonData.keyOwners.get(key)) !== null && _a !== void 0 ? _a : [];
                    currJsonData.keyOwners.set(key, [...currModules, module.name]);
                });
                configKeysToOwnerModules.set(jsonPath, currJsonData);
            });
        }
        // Ensure that there's no interesection between owned regular files and files with owned JSON keys.
        const moduleOwnedFiles = [...filesToOwnerModules.keys()];
        const moduleOwnedJsonConfs = new Set(configKeysToOwnerModules.keys());
        moduleOwnedFiles
            .filter((path) => moduleOwnedJsonConfs.has(path))
            .forEach((path) => {
            var _a, _b;
            const fileModules = (_a = filesToOwnerModules.get(path)) === null || _a === void 0 ? void 0 : _a.join(', ');
            const keyModules = (_b = configKeysToOwnerModules.get(path)) === null || _b === void 0 ? void 0 : _b.fileOwners.join(', ');
            errors.push(`File "${path}" is owned by modules: "${fileModules}". However, it also has keys that are owned by modules: "${keyModules}".`);
        });
        // Ensure that all owned files exist in the filesystem.
        const scaffoldingFilePaths = new Set((await (0, globby_1.default)((0, path_1.resolve)(this.scaffoldDir, '**/*'), { dot: true })).map((p) => p.replace(`${this.scaffoldDir}/`, '')).filter((p) => p !== ''));
        moduleOwnedFiles
            .filter((path) => !scaffoldingFilePaths.has(path))
            .forEach((path) => {
            var _a;
            const fileModules = (_a = filesToOwnerModules.get(path)) === null || _a === void 0 ? void 0 : _a.join(', ');
            errors.push(`File "${path}" is owned by modules: "${fileModules}", but it doesn't exist in the scaffolding directory.`);
        });
        [...moduleOwnedJsonConfs]
            .filter((path) => !scaffoldingFilePaths.has(path))
            .forEach((path) => {
            var _a;
            const keyModules = (_a = configKeysToOwnerModules.get(path)) === null || _a === void 0 ? void 0 : _a.fileOwners.join(', ');
            errors.push(`File "${path}" has keys owned by modules: "${keyModules}", but it doesn't exist in the scaffolding directory.`);
        });
        // Ensure that all files in the filesystem are owned by at least one module.
        [...scaffoldingFilePaths]
            .filter((path) => !filesToOwnerModules.has(path) && !configKeysToOwnerModules.has(path))
            .forEach((path) => {
            errors.push(`File "${path}" is not owned by any module.`);
        });
        // Ensure that every template param is used by at least one module.
        this.templateParams
            .filter((p) => !templateParamsToUsingModules.has((0, template_param_1.getParamName)(p)))
            .forEach((p) => {
            errors.push(`Template param "${(0, template_param_1.getParamName)(p)}" is defined, but not used by any modules.`);
        });
        // Ensure that every module's needed template params are provided.
        const providedParams = new Set(this.templateParams.map((p) => (0, template_param_1.getParamName)(p)));
        [...templateParamsToUsingModules.keys()]
            .filter((paramName) => !providedParams.has(paramName))
            .forEach((paramName) => {
            var _a;
            const paramModules = (_a = templateParamsToUsingModules.get(paramName)) === null || _a === void 0 ? void 0 : _a.join(', ');
            errors.push(`Template param "${paramName}" is used by modules: "${paramModules}", but is not provided.`);
        });
        // Ensure that for owned JSON files, all keys are owned by at least one module.
        [...configKeysToOwnerModules.entries()]
            .filter(([path]) => scaffoldingFilePaths.has(path))
            .forEach(([path, ownerData]) => {
            // Flush pending errors before readTpl calls, because
            // if that fails due to templating syntax issues, no other
            // errors will be shared, and those other errors commonly
            // are the cause of template errors (e.g. missing params).
            if (errors.length > 0) {
                throw new Error(errors.join('\n'));
            }
            const contents = (0, read_tpl_1.readTpl)((0, path_1.resolve)(this.scaffoldDir, path), tplData);
            let json;
            try {
                json = JSON.parse(contents);
                const keys = new Set((0, json_leaf_paths_1.jsonLeafPaths)(json));
                [...keys]
                    .filter((k) => !ownerData.keyOwners.has(k))
                    .forEach((k) => {
                    errors.push(`Key "${k}" in file "${path}" is not owned by any module.`);
                });
                [...ownerData.keyOwners.entries()]
                    .filter(([k]) => !keys.has(k))
                    .forEach(([k, owners]) => {
                    errors.push(`Key "${k}" is owned by modules: "${owners.join(', ')}", but does not exist in file "${path}".`);
                });
            }
            catch (error) {
                if (error instanceof SyntaxError) {
                    errors.push(`File "${path}" is invalid JSON: ${error.message}`);
                }
                else {
                    errors.push(String(error));
                }
            }
        });
        // Flush pending errors again, as if we run into problems during `readTpl`,
        // we won't be able to express other errors.
        if (errors.length > 0) {
            throw new Error(errors.join('\n'));
        }
        // Ensure that all files can be resolved with ejs using provided template variables.
        scaffoldingFilePaths.forEach((path) => {
            (0, read_tpl_1.readTpl)((0, path_1.resolve)(this.scaffoldDir, path), tplData);
        });
    }
}
exports.Scaffolder = Scaffolder;
