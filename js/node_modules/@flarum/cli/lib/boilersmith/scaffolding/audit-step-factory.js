"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.auditStepFactory = void 0;
const tslib_1 = require("tslib");
const mem_fs_1 = require("mem-fs");
const rename_keys_1 = require("../utils/rename-keys");
const module_1 = require("./module");
const template_param_1 = require("./template-param");
const cond_format_1 = require("boilersmith/utils/cond-format");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const fs_1 = require("fs");
function auditStepFactory(dry, scaffoldDir, modules, templateParams, excludeScaffoldingFunc, moduleStatusCache) {
    let modulesEnabled;
    return {
        type: 'Audit for outdated infrastructure files or config.',
        composable: true,
        async run(_fs, paths, io, _providers) {
            const paramVals = await (0, template_param_1.currParamValues)(templateParams, _fs, paths, io);
            modulesEnabled = await (0, module_1.currModulesEnabled)(modules, _fs, paths, moduleStatusCache);
            const actionableModules = modules.filter((m) => m.updatable && modulesEnabled[m.name] && (!m.togglable || !m.dependsOn.some((dep) => !modulesEnabled[dep])));
            io.info((0, cond_format_1.condFormat)(io.supportsAnsiColor, (m) => chalk_1.default.yellow(chalk_1.default.bold(chalk_1.default.underline(m))), `Auditing infrastructure for ${actionableModules.length} enabled modules:`), true);
            for (const m of modules) {
                if (actionableModules.includes(m)) {
                    io.info((0, cond_format_1.condFormat)(io.supportsAnsiColor, (m) => chalk_1.default.dim(chalk_1.default.green(m)), `✓ ${m.name}: ${m.shortDescription}`), true);
                }
                else if (m.updatable) {
                    io.info((0, cond_format_1.condFormat)(io.supportsAnsiColor, (m) => chalk_1.default.dim(chalk_1.default.red(m)), `✕ ${m.name}: ${m.shortDescription} (disabled)`), true);
                }
            }
            for (const m of actionableModules) {
                const fs = dry ? (0, mem_fs_1.create)() : _fs;
                const excludeScaffolding = excludeScaffoldingFunc ? excludeScaffoldingFunc(fs, paths) : { files: [], configKeys: {} };
                (0, module_1.applyModule)(m, modulesEnabled, paramVals, scaffoldDir, fs, paths, excludeScaffolding, true);
                if (dry) {
                    const filesWithChanges = fs
                        .all()
                        .filter((f) => f.state && f.state !== 'deleted')
                        .filter((f) => { var _a; return !(0, fs_1.existsSync)(f.path) || (0, fs_1.readFileSync)(f.path, 'utf8').toString() !== ((_a = f.contents) === null || _a === void 0 ? void 0 : _a.toString()); });
                    if (filesWithChanges.length > 0) {
                        io.error(`Module ${m.name} has ${filesWithChanges.length} changed files: ${filesWithChanges
                            .map((f) => f.path.replace(paths.package() + '/', ''))
                            .join(', ')}`, false);
                    }
                }
            }
            if (!dry) {
                for (const m of modules) {
                    if (moduleStatusCache && m.updatable && (actionableModules.includes(m) || m.togglable)) {
                        (0, module_1.setModuleValue)(m, actionableModules.includes(m), _fs, paths, moduleStatusCache);
                    }
                }
            }
            return _fs;
        },
        exposes: modules.map((m) => `modules.${m.name}`),
        getExposed(_paths, _paramProvider) {
            return (0, rename_keys_1.renameKeys)(modulesEnabled, (k) => `modules.${k}`);
        },
    };
}
exports.auditStepFactory = auditStepFactory;
