import { Store } from 'mem-fs';
import { Paths } from '../paths';
import { DefaultProviders, Step } from '../step-manager';
import { Module, ModuleStatusCache } from './module';
import { TemplateParam } from './template-param';
import { IO } from 'boilersmith/io';
export declare type ExcludeScaffoldingFunc = (fs: Store, paths: Paths) => {
    files: string[];
    configKeys: Record<string, string[]>;
};
export declare class Scaffolder<TN extends string = string, MN extends string = string> {
    private templateParams;
    private modules;
    private scaffoldDir;
    private moduleStatusCache?;
    private excludeScaffoldingFunc?;
    constructor(scaffoldDir: string);
    constructor(scaffoldDir: string, moduleStatusCache: ModuleStatusCache<MN>);
    constructor(scaffoldDir: string, moduleStatusCache: ModuleStatusCache<MN>, excludeScaffoldingFuncs: ExcludeScaffoldingFunc);
    registerModule(module: Module<MN>): this;
    registerTemplateParam<T>(templateParam: TemplateParam<T, TN>): this;
    genInitStep<Providers extends DefaultProviders>(): Step<Providers>;
    genInfraStep<Providers extends DefaultProviders>(module: string): Step<Providers>;
    genAuditStep<Providers extends DefaultProviders>(dry?: boolean): Step<Providers>;
    templateParamVal<T>(param: TN, fs: Store, paths: Paths, io: IO): Promise<T>;
    templateParamVals(fs: Store, paths: Paths, io: IO): Promise<Record<TN, unknown>>;
    modulesEnabled(fs: Store, paths: Paths): Promise<Record<MN, boolean>>;
    moduleFiles(moduleName: MN): string[];
    /**
     * Confirm that all files and configuration keys in the scaffolding dir
     * are owned by at least one module, and that no modules own nonexistent
     * files or configuration keys.
     */
    validate(): Promise<void>;
}
