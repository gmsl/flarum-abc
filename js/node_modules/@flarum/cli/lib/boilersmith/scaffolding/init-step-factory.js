"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initStepFactory = void 0;
const rename_keys_1 = require("../utils/rename-keys");
const module_1 = require("./module");
const template_param_1 = require("./template-param");
function initStepFactory(scaffoldDir, modules, templateParams, excludeScaffoldingFunc, moduleStatusCache) {
    let modulesEnabled;
    return {
        type: 'Generate package skeleton',
        composable: true,
        async run(fs, paths, io, _providers) {
            const paramVals = await (0, template_param_1.promptParamValues)(templateParams, paths, io);
            modulesEnabled = await (0, module_1.promptModulesEnabled)(modules, io);
            const excludeScaffolding = excludeScaffoldingFunc ? excludeScaffoldingFunc(fs, paths) : { files: [], configKeys: {} };
            for (const m of modules) {
                if (modulesEnabled[m.name] && (!m.togglable || !m.dependsOn.some((dep) => !modulesEnabled[dep]))) {
                    (0, module_1.applyModule)(m, modulesEnabled, paramVals, scaffoldDir, fs, paths, excludeScaffolding, true);
                }
            }
            if (moduleStatusCache) {
                modules.forEach((m) => {
                    (0, module_1.setModuleValue)(m, modulesEnabled[m.name], fs, paths, moduleStatusCache);
                });
            }
            return fs;
        },
        exposes: modules.map((m) => `modules.${m.name}`),
        getExposed(_paths, _paramProvider) {
            return (0, rename_keys_1.renameKeys)(modulesEnabled, (k) => `modules.${k}`);
        },
    };
}
exports.initStepFactory = initStepFactory;
