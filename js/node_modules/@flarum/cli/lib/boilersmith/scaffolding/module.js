"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyModule = exports.setModuleValue = exports.currModulesEnabled = exports.promptModulesEnabled = void 0;
const tslib_1 = require("tslib");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const mem_fs_editor_1 = require("mem-fs-editor");
const path_1 = require("path");
const pick_deep_1 = (0, tslib_1.__importDefault)(require("pick-deep"));
const read_tpl_1 = require("boilersmith/utils/read-tpl");
const clone_and_fill_1 = require("boilersmith/utils/clone-and-fill");
const rename_keys_1 = require("boilersmith/utils/rename-keys");
const cond_format_1 = require("boilersmith/utils/cond-format");
async function promptModulesEnabled(modules, io) {
    const modulesEnabled = {};
    const advanced = await io.getParam({
        name: 'advancedInstallation',
        type: 'confirm',
        initial: false,
        message: `Advanced Initialization ${(0, cond_format_1.condFormat)(io.supportsAnsiColor, chalk_1.default.dim, '(fine-tune which features are enabled)')}`,
    });
    for (const m of modules) {
        const missingDeps = !m.togglable || m.dependsOn.some((dep) => !modulesEnabled[dep]);
        if (!m.togglable) {
            modulesEnabled[m.name] = true;
        }
        else if (missingDeps) {
            modulesEnabled[m.name] = false;
        }
        else if (advanced) {
            // eslint-disable-next-line no-await-in-loop
            modulesEnabled[m.name] = await io.getParam({
                name: `modules.${m.name}`,
                type: 'confirm',
                initial: m.defaultEnabled,
                message: m.shortDescription + (m.longDescription ? (0, cond_format_1.condFormat)(io.supportsAnsiColor, chalk_1.default.dim, ` (${m.longDescription})`) : ''),
            });
        }
        else {
            modulesEnabled[m.name] = m.defaultEnabled;
        }
    }
    return modulesEnabled;
}
exports.promptModulesEnabled = promptModulesEnabled;
async function currModulesEnabled(modules, fs, paths, cache) {
    var _a, _b;
    const modulesEnabled = {};
    for (const m of modules) {
        if (m.togglable) {
            // eslint-disable-next-line no-await-in-loop
            const isEnabled = (_a = (await (cache === null || cache === void 0 ? void 0 : cache.get(m, fs, paths)))) !== null && _a !== void 0 ? _a : (await ((_b = m.inferEnabled) === null || _b === void 0 ? void 0 : _b.call(m, fs, paths)));
            modulesEnabled[m.name] = isEnabled !== null && isEnabled !== void 0 ? isEnabled : m.defaultEnabled;
        }
        else {
            modulesEnabled[m.name] = true;
        }
    }
    return modulesEnabled;
}
exports.currModulesEnabled = currModulesEnabled;
async function setModuleValue(module, enabled, fs, paths, cache) {
    if (module.togglable) {
        cache.set(module, enabled, fs, paths);
    }
}
exports.setModuleValue = setModuleValue;
// eslint-disable-next-line max-params,complexity
async function applyModule(module, modulesEnabled, paramVals, scaffoldDir, fs, paths, 
// eslint-disable-next-line unicorn/no-object-as-default-parameter
excludeScaffolding = { files: [], configKeys: {} }, isInitial = false) {
    var _a, _b;
    const fsEditor = (0, mem_fs_editor_1.create)(fs);
    // Validate that module can be enabled
    if (!(modulesEnabled === null || modulesEnabled === void 0 ? void 0 : modulesEnabled[module.name])) {
        throw new Error(`Could not apply module "${module.name}", because it is not enabled in the provided module statuses.`);
    }
    // Validate that dependencies are enabled
    const missingDeps = module.togglable ? module.dependsOn.filter((dep) => !modulesEnabled[dep]) : [];
    if (missingDeps.length > 0) {
        throw new Error(`Could not apply module "${module.name}", because the following dependency modules are missing: "${missingDeps.join(', ')}".`);
    }
    // Validate that all needed params are present
    const missingParams = module.needsTemplateParams.filter((p) => !(p in paramVals));
    if (missingParams.length > 0) {
        throw new Error(`Could not apply module "${module.name}", because the following params are missing: "${missingParams.join(', ')}".`);
    }
    if (!isInitial && !module.updatable) {
        throw new Error(`Cannot update module "${module.name}", as it is not updatable, and has already been initialized.`);
    }
    const tplData = {
        params: paramVals,
        modules: modulesEnabled,
    };
    const tplDataFlat = Object.assign(Object.assign({}, (0, rename_keys_1.renameKeys)(tplData.modules, (k) => `modules.${k}`)), (0, rename_keys_1.renameKeys)(tplData.params, (k) => `params.${k}`));
    // This is necessary because one layer of escaped backslashes is lost on template population.
    tplData.params = Object.fromEntries(Object.entries(paramVals).map(([k, v]) => [k, typeof v === 'string' ? v.replace('\\', '\\\\') : v]));
    for (const file of module.filesToReplace) {
        const path = typeof file === 'string' ? file : file.path;
        const moduleDeps = typeof file === 'string' ? [] : (_a = file.moduleDeps) !== null && _a !== void 0 ? _a : [];
        const copyToIfMonorepo = typeof file !== 'string' && 'monorepoPath' in file && file.monorepoPath
            ? paths.monorepo((0, clone_and_fill_1.cloneAndFill)(file.monorepoPath, tplDataFlat))
            : undefined;
        const copyTo = copyToIfMonorepo !== null && copyToIfMonorepo !== void 0 ? copyToIfMonorepo : paths.package(typeof file !== 'string' && file.destPath ? (0, clone_and_fill_1.cloneAndFill)(file.destPath, tplDataFlat) : path);
        if (typeof file !== 'string' && file.doNotUpdate && fsEditor.exists(copyTo)) {
            continue;
        }
        if (typeof file !== 'string' && 'requireMonorepo' in file && file.requireMonorepo && paths.monorepo() === null) {
            continue;
        }
        if (excludeScaffolding.files.includes(path) ||
            moduleDeps.some((dep) => {
                const depName = typeof dep === 'string' ? dep : dep.module;
                const enabled = modulesEnabled[depName];
                return typeof dep === 'string' || dep.enabled ? !enabled : enabled;
            })) {
            continue;
        }
        let source = (0, read_tpl_1.readTpl)((0, path_1.resolve)(scaffoldDir, path), tplData);
        if (fsEditor.exists(copyTo)) {
            source = applyCustomizations(source, fsEditor.read(copyTo));
        }
        fsEditor.write(copyTo, source);
    }
    const jsonPaths = (0, clone_and_fill_1.cloneAndFill)(module.jsonToAugment, tplDataFlat);
    for (const jsonPath of Object.keys(jsonPaths)) {
        const scaffoldContents = (0, read_tpl_1.readTpl)((0, path_1.resolve)(scaffoldDir, jsonPath), tplData);
        const scaffoldContentsJson = JSON.parse(scaffoldContents);
        const excludeKeys = (0, clone_and_fill_1.cloneAndFill)((_b = excludeScaffolding.configKeys[jsonPath]) !== null && _b !== void 0 ? _b : [], tplDataFlat);
        const fieldsToAugment = jsonPaths[jsonPath].filter((key) => !excludeKeys.includes(key));
        const relevant = (0, pick_deep_1.default)(scaffoldContentsJson, fieldsToAugment);
        fsEditor.extendJSON(paths.package(jsonPath), relevant, undefined, 4);
    }
    return fs;
}
exports.applyModule = applyModule;
function applyCustomizations(source, curr) {
    const commentStructures = [
        ['//', '\n'],
        ['/*', ' */'],
        ['<!--', '-->'],
        ['#', '\n'],
    ];
    commentStructures.forEach((x) => x);
    return commentStructures.reduce((acc, [start, end]) => {
        const CUSTOMIZATION_REGEX = new RegExp(`(${start}\\s*<CUSTOM-(?<id>.*)>\\s*${end})(?<contents>.*)(${start}\\s*</CUSTOM-\\k<id>>\\s*${end})`, 'gs');
        const matches = curr.matchAll(CUSTOMIZATION_REGEX);
        const customizations = Object.fromEntries([...matches]
            .map((m) => m.groups)
            .filter(Boolean)
            .map((g) => [g === null || g === void 0 ? void 0 : g.id, g === null || g === void 0 ? void 0 : g.contents]));
        return acc.replace(CUSTOMIZATION_REGEX, (_m, open, id, _c, close) => { var _a; return `${open}${(_a = customizations[id]) !== null && _a !== void 0 ? _a : ''}${close}`; });
    }, source);
}
