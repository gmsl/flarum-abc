import { Store } from 'mem-fs';
import { IO } from 'boilersmith/io';
import { Paths } from 'boilersmith/paths';
import { ExcludeScaffoldingFunc } from './scaffolder';
declare type FileOwnershipCommon<N extends string> = {
    /**
     * The path to the file
     */
    path: string;
    /**
     * Where the file should go. Defaults to path.
     */
    destPath?: string;
    /**
     * Depends on other modules being enabled (or disabled).
     */
    moduleDeps?: (N | {
        module: N;
        enabled: boolean;
    })[];
    /**
     * Only create the file if it doesn't exist; do not update existing files.
     */
    doNotUpdate?: boolean;
};
declare type FileOwnership<N extends string> = (FileOwnershipCommon<N> & {
    /**
     * If in a monorepo, should the file be placed relative to the monorepo root, and if so, where?
     * If provided, takes priority over destPath.
     */
    monorepoPath: string;
    /**
     * Only place this file if in a monorepo?
     */
    requireMonorepo: boolean;
}) | FileOwnershipCommon<N>;
interface CommonModule<N extends string> {
    name: N;
    shortDescription: string;
    longDescription?: string;
    /**
     * Whether files belonging to this module should be kept up to date.
     */
    updatable: boolean;
    /**
     * A list of scaffolding files managed by this module.
     */
    filesToReplace: (string | FileOwnership<N>)[];
    /**
     * A map of names of JSON files to keys which should be deep-merged from the scaffolding.
     */
    jsonToAugment: Record<string, string[]>;
    /**
     * An array of names of template params needed by this module.
     */
    needsTemplateParams: string[];
}
interface UntoggleableModule<N extends string> extends CommonModule<N> {
    /**
     * Whether this module can be enabled/disabled.
     */
    togglable: false;
}
interface TogglableModule<N extends string> extends CommonModule<N> {
    /**
     * Whether this module can be enabled/disabled.
     */
    togglable: true;
    /**
     * Whether this module is enabled or disabled by default.
     */
    defaultEnabled: boolean;
    /**
     * Can only be enabled if these other modules are enabled.
     */
    dependsOn: N[];
    /**
     * On an existing installation, if no information about whether this
     * module is enabled or disabled is cached, infer whether it's enabled
     * based on the current installation's state.
     */
    inferEnabled?: (fs: Store, paths: Paths) => Promise<boolean | undefined>;
}
export declare type Module<N extends string = string> = UntoggleableModule<N> | TogglableModule<N>;
export declare type ModuleStatusCache<N extends string> = {
    get: (module: Module<N>, fs: Store, paths: Paths) => Promise<boolean | undefined>;
    set: (module: Module<N>, val: boolean, fs: Store, paths: Paths) => Promise<void>;
};
export declare function promptModulesEnabled<N extends string>(modules: Module<N>[], io: IO): Promise<Record<N, boolean>>;
export declare function currModulesEnabled<N extends string>(modules: Module<N>[], fs: Store, paths: Paths, cache?: ModuleStatusCache<N>): Promise<Record<N, boolean>>;
export declare function setModuleValue<MN extends string>(module: Module<MN>, enabled: boolean, fs: Store, paths: Paths, cache: ModuleStatusCache<MN>): Promise<void>;
export declare function applyModule<MN extends string, TN extends string>(module: Module<MN>, modulesEnabled: Record<string, boolean>, paramVals: Record<TN, unknown>, scaffoldDir: string, fs: Store, paths: Paths, excludeScaffolding?: ReturnType<ExcludeScaffoldingFunc>, isInitial?: boolean): Promise<Store>;
export {};
