"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromptsIO = void 0;
const tslib_1 = require("tslib");
const prompts_1 = (0, tslib_1.__importDefault)(require("prompts"));
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
class PromptsIO {
    constructor(initial = {}, messages = [], noInteraction = false, onCancel = () => {
        throw new Error('EEXIT: 0');
    }) {
        this.supportsAnsiColor = true;
        this.cache = new Map();
        this.cache = new Map(Object.entries(initial));
        this.messages = messages;
        this.noInteraction = noInteraction;
        this.onCancel = onCancel;
    }
    async getParam(paramDef, noCache = false) {
        var _a, _b, _c;
        const paramName = paramDef.name;
        if (this.cache.has(paramName)) {
            return this.cache.get(paramName);
        }
        let resValue;
        if (this.noInteraction) {
            if (paramDef.initial && paramDef.initial instanceof Function) {
                resValue = paramDef.initial((_a = this.prev) === null || _a === void 0 ? void 0 : _a.val, this.cache, (_b = this.prev) === null || _b === void 0 ? void 0 : _b.prompt);
            }
            else if (paramDef.type === 'confirm' || paramDef.type === 'toggle') {
                resValue = ((_c = paramDef.initial) !== null && _c !== void 0 ? _c : false);
            }
            else if ('initial' in paramDef) {
                resValue = paramDef.initial;
            }
            else {
                return this.error(`No-Interaction mode is on, but input is required for param "${paramName}".`, true);
            }
        }
        else {
            const res = (await (0, prompts_1.default)(paramDef, {
                onCancel: this.onCancel,
            }));
            resValue = res[paramName];
        }
        if (!noCache) {
            this.cache.set(paramName, resValue);
        }
        this.prev = {
            val: resValue,
            prompt: paramDef,
        };
        return resValue;
    }
    hasCached(name) {
        return this.cache.has(name);
    }
    /**
     * @internal
     */
    cached() {
        return [...this.cache].reduce((obj, [key, value]) => {
            obj[key] = value;
            return obj;
        }, {});
    }
    info(message, immediate) {
        if (immediate) {
            console.log(message);
        }
        else {
            this.messages.push({ type: 'info', message });
        }
    }
    warning(message, immediate) {
        const formatted = `${chalk_1.default.yellow('Warning:')} ${message}`;
        if (immediate) {
            console.log(formatted);
        }
        else {
            this.messages.push({ type: 'warning', message: formatted });
        }
    }
    error(message, immediate) {
        const formatted = `${chalk_1.default.red('Error:')} ${message}`;
        if (immediate) {
            throw new Error(message);
        }
        else {
            this.messages.push({ type: 'error', message: formatted });
        }
    }
    getOutput() {
        return this.messages;
    }
    newInstance(cache, messages) {
        return new PromptsIO(cache, messages, this.noInteraction, this.onCancel);
    }
}
exports.PromptsIO = PromptsIO;
